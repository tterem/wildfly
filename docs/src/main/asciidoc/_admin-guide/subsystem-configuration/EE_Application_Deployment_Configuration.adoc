[[EE_Application_Deployment_Configuration]]
= Java EE Application Deployment

The EE subsystem configuration allows the customisation of the
deployment behaviour for Java EE Applications.

[[global-modules]]
== Global Modules

Global modules is a set of JBoss Modules that will be added as
dependencies to the JBoss Module of every Java EE deployment. Such
dependencies allows Java EE deployments to see the classes exported by
the global modules.

Each global module is defined through the `module` resource, an example
of its XML configuration:

[source,xml,options="nowrap"]
----
  <global-modules>
    <module name="org.jboss.logging" slot="main"/>
    <module name="org.apache.log4j" annotations="true" meta-inf="true" services="false" />
  </global-modules>
----

The only mandatory attribute is the JBoss Module `name`, the `slot`
attribute defaults to `main`, and both define the JBoss Module ID to
reference.

The optional `annotations` attribute, which defaults to `false`,
indicates if a pre-computed annotation index should be imported from
META-INF/jandex.idx

The optional `services` attribute indicates if any services exposed in
META-INF/services should be made available to the deployments class
loader, and defaults to `false`.

The optional `meta-inf` attribute, which defaults to `true`, indicates
if the Module's `META-INF` path should be available to the deployment's
class loader.

[[global-directories]]
== Global Directories
Global modules can be used to shared common libraries across all deployed applications, but it could be unpractical if the name of a shared library changes very often or if there are many libraries you want to share. Both cases requires changes in the module.xml you are sharing as a global module.

The EE subsystem allows the configuration of global directories, which are directories scanned to include additional .jar files and resources as dependencies of your deployed applications.

You can configure a global directory using the following operation:

[source,xml,options="nowrap"]
----
  [standalone@localhost:9990 /] /subsystem=ee/global-directory=my-common-libs:add(path=lib, relative-to=jboss.home.dir)
----

The following attributes are available on the global-directory resource:

* path: The path of the directory to scan. (Mandatory)
* relative-to: The name of another previously named path, or of one of the standard paths provided by the system. (Optional)

When a new `global-directory` is created, the server creates a module that will have one https://jboss-modules.github.io/jboss-modules/manual/#path-resource-loader[Path Resource Loader] created using 'path' and 'relative-to' attributes and one https://jboss-modules.github.io/jboss-modules/manual/#jar-resource-loader[Jar Resource loader] for each jar file included in this directory and subdirectories.

The 'Path Resource Loader' will make available any file as a resource to the applications. The 'Jar Resource loader' will make available any class inside of the jar file to the applications.

For example, suppose you have configured one a global directory pointing to the following directory:

....
my-common-libs
|
|-- library-1.jar
|-- properties-1.properties
|
|─ sub-dir
|   |-- library-2.jar
    |-- properties-2.properties
....

properties-1.properties and sub-dir/properties-2.properties files will be available as resources in the class loader of your application. You could access to those files using the context ClassLoader of your current thread:

  Thread.currentThread().getContextClassLoader().getResourceAsStream("properties-1.properties");
  Thread.currentThread().getContextClassLoader().getResourceAsStream("sub-dir/properties-2.properties");

The classes inside of library-1.jar and sub-dir/library-2.jar will be also available. However, there could be name collisions between classes inside of each jar. The jar resources of a global directory module are configured iterating over all jar files in alphabetical order and size descending, and this order governs the class loading order of the classes available on each jar resource.

The module created from the shared directory is loaded as soon as the first application is deployed in the server. That means, if the server is started/restarted and there are no applications deployed, then the global directory is neither scanned nor the module loaded.

In case of domain mode or distributed environments, it is the user responsibility to make the content of the configured global directory consistent across all the server instances, as well as distribute the jar files that they contain.


[[ear-subdeployments-isolation]]
== EAR Subdeployments Isolation

A flag indicating whether each of the subdeployments within a `.ear` can
access classes belonging to another subdeployment within the same
`.ear`. The default value is `false`, which allows the subdeployments to
see classes belonging to other subdeployments within the `.ear`.

[source,xml,options="nowrap"]
----
  <ear-subdeployments-isolated>true</ear-subdeployments-isolated>
----

For example:

....
myapp.ear
|
|--- web.war
|
|--- ejb1.jar
|
|--- ejb2.jar
....

If the `ear-subdeployments-isolated` is set to false, then the classes
in `web.war` can access classes belonging to `ejb1.jar` and `ejb2.jar`.
Similarly, classes from `ejb1.jar` can access classes from `ejb2.jar`
(and vice-versa).

[NOTE]

This flag has no effect on the isolated classloader of the `.war`
file(s), i.e. irrespective of whether this flag is set to `true` or
`false`, the `.war` within a `.ear` will have a isolated classloader,
and other subdeployments within that `.ear` will not be able to access
classes from that `.war`. This is as per spec.

[[property-replacement]]
== Property Replacement

The EE subsystem configuration includes flags to configure whether
system property replacement will be done on XML descriptors and Java
Annotations included in Java EE deployments.

[NOTE]

System properties etc are resolved in the security context of the
application server itself, not the deployment that contains the file.
This means that if you are running with a security manager and enable
this property, a deployment can potentially access system properties or
environment entries that the security manager would have otherwise
prevented.

[[spec-descriptor-property-replacement]]
=== Spec Descriptor Property Replacement

Flag indicating whether system property replacement will be performed on
standard Java EE XML descriptors. If not configured this defaults to
`true`, however it is set to `false` in the standard configuration files
shipped with WildFly.

[source,xml,options="nowrap"]
----
  <spec-descriptor-property-replacement>false</spec-descriptor-property-replacement>
----

[[jboss-descriptor-property-replacement]]
=== JBoss Descriptor Property Replacement

Flag indicating whether system property replacement will be performed on
WildFly proprietary XML descriptors, such as `jboss-app.xml`. This
defaults to `true`.

[source,xml,options="nowrap"]
----
  <jboss-descriptor-property-replacement>false</jboss-descriptor-property-replacement>
----

[[annotation-property-replacement]]
=== Annotation Property Replacement

Flag indicating whether system property replacement will be performed on
Java annotations. The default value is `false`.

[source,xml,options="nowrap"]
----
  <annotation-property-replacement>false</annotation-property-replacement>
----
